<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>线性模型</title>
    <link href="/2022/04/26/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/04/26/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h1><h2 id="1、线性回归"><a href="#1、线性回归" class="headerlink" title="1、线性回归"></a>1、线性回归</h2><p>假如咱们有一个数据集，里面的数据是俄勒冈州波特兰市的 $47$ 套房屋的面积和价格：</p><table><thead><tr><th align="center">居住面积（平方英尺）</th><th align="center">价格（千美元）</th></tr></thead><tbody><tr><td align="center">$2104$</td><td align="center">$400$</td></tr><tr><td align="center">$1600$</td><td align="center">$330$</td></tr><tr><td align="center">$2400$</td><td align="center">$369$</td></tr><tr><td align="center">$1416$</td><td align="center">$232$</td></tr><tr><td align="center">$3000$</td><td align="center">$540$</td></tr><tr><td align="center">……</td><td align="center">……</td></tr></tbody></table><p><img src="/./image/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/1.png"></p><p>如果来了一个新的面积，假设在销售价钱的记录中没有的，我们怎么办呢？</p><p>我们可以用一条曲线去尽量准的拟合这些数据，然后如果有新的输入过来，我们可以将曲线上这个点对应的值返回。这就是线性回归的思想。</p><p>为了让我们的房屋案例更有意思，咱们稍微对数据集进行一下补充，增加上每一个房屋的卧室数目：</p><table><thead><tr><th align="center">居住面积（平方英尺）</th><th align="center">卧室数目</th><th align="center">价格（千美元）</th></tr></thead><tbody><tr><td align="center">$2104$</td><td align="center">$3$</td><td align="center">$400$</td></tr><tr><td align="center">$1600$</td><td align="center">$3$</td><td align="center">$330$</td></tr><tr><td align="center">$2400$</td><td align="center">$3$</td><td align="center">$369$</td></tr><tr><td align="center">$1416$</td><td align="center">$2$</td><td align="center">$232$</td></tr><tr><td align="center">$3000$</td><td align="center">$4$</td><td align="center">$540$</td></tr><tr><td align="center">……</td><td align="center">……</td><td align="center">……</td></tr></tbody></table><p>也是同样的方法，此时的自变量就变成了二维向量。</p><p>下面是一个典型的机器学习的过程，首先给出一个输入数据，我们的算法会通过一系列的过 程得到一个估计的函数，这个函数有能力对没有见过的新数据给出一个新的估计，也被称为构建一个模型。就如同上面的线性回归函数。</p><p><img src="/./image/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/2.png"></p><p>线性回归假设特征和结果满足线性关系。其实线性关系的表达能力非常强大，每个特征 对结果的影响强弱可以有前面的参数体现，而且每个特征变量可以首先映射到一个函数，然后再参与线性计算。这样就可以表达特征与结果之间的非线性关系。</p><p>我们用$x_1$，$x_2$去描述feature里面的分量，比如 $x_1$&#x3D;居住面积，$x_2$&#x3D;卧室数目，我们可以做出一个估计函数：<br>$$<br>h_\theta  (x) &#x3D; \theta_0 + \theta_1 \times x_1 + \theta_2 \times x_2<br>$$<br>简化一下就为：<br>$$<br>h(x) &#x3D; \sum^n_{i&#x3D;0}  \theta_i x_i &#x3D; \theta^T x<br>$$<br>我们程序也需要一个机制去评估我们$\theta$是否比较好，所以说需要对我们做出的$h$函数进行 评估，一般这个函数称为损失函数（loss function）或者错误函数(error function)，描述$h$函 数不好的程度，在下面，我们称这个函数为$J$函数：<br>$$<br>J(\theta) &#x3D; \frac 12 \sum^m_{i&#x3D;1}(h_\theta(x^{(i)})-y^{(i)})^2<br>$$<br>如何调整$\theta$以使得$J(\theta)$取得最小值有很多方法，其中有最小二乘法(least squares method)和梯度下降法等。</p><h3 id="1-1-最小二乘法"><a href="#1-1-最小二乘法" class="headerlink" title="1.1  最小二乘法"></a>1.1  最小二乘法</h3><p>给定一个训练集，把<strong>设计矩阵（design matrix）</strong> $x$ 设置为一个 $m\times n$ 矩阵（实际上，如果考虑到截距项，也就是 $\theta_0$ 那一项，就应该是 $m\times (n+1)$ 矩阵），这个矩阵里面包含了训练样本的输入值作为每一行：</p><p>$$<br>X &#x3D;\begin{bmatrix}<br>(x^{(1)}) ^T\<br>(x^{(2)}) ^T\<br>\vdots \<br>(x^{(m)}) ^T\<br>\end{bmatrix}<br>$$</p><p>然后，咱们设 $\vec{y}$ 是一个 $m$ 维向量（m-dimensional vector），其中包含了训练集中的所有目标值：</p><p>$$<br>Y &#x3D;\begin{bmatrix}<br>y^{(1)}\<br>y^{(2)}\<br>\vdots \<br>y^{(m)}\<br>\end{bmatrix}<br>$$</p><p>假设$h_\theta(x_1,x_2,…,x_m)&#x3D;\theta_0+ \theta_1 \times x_1 + \theta_2 \times x_2 + … +\theta \times x_m$​ 的矩阵表达式为<br>$$<br>h_\theta(x)&#x3D;X_\theta<br>$$<br>损失函数定义为：<br>$$<br>\frac \partial {\partial\theta_j}J(\theta) &#x3D; \frac12 (X_\theta - Y) ^ T (X_\theta - T)<br>$$<br>这时候我们要对这个损失函数的 $\theta$ 向量进行求导取0，结果如下式：<br>$$<br>\theta &#x3D; (X^T X)^{-1} X^T Y<br>$$</p><h3 id="1-2-梯度下降算法"><a href="#1-2-梯度下降算法" class="headerlink" title="1.2 梯度下降算法"></a>1.2 梯度下降算法</h3><p>我们希望选择一个能让 $J(\theta)$ 最小的 $\theta$ 值。怎么做呢，咱们先用一个搜索的算法，从某一个对 $\theta$ 的“初始猜测值”，然后对 $\theta$ 值不断进行调整，来让 $J(\theta)$ 逐渐变小，最好是直到我们能够达到一个使 $J(\theta)$ 最小的 $\theta$。具体来说，咱们可以考虑使用梯度下降法（gradient descent algorithm），这个方法就是从某一个 $\theta$ 的初始值开始，然后逐渐重复更新：</p><p>$$<br>\theta_j :&#x3D; \theta_j - \alpha \frac \partial {\partial\theta_j}J(\theta)<br>$$</p><p>（上面的这个更新要同时对应从 $0$ 到 $n$ 的所有$j$ 值进行。）这里的 $\alpha$ 也称为学习速率。这个算法是很自然的，逐步重复朝向 $J$ 降低最快的方向移动。</p><p>要实现这个算法，咱们需要解决等号右边的导数项。首先来解决只有一组训练样本 $(x, y)$ 的情况，这样就可以忽略掉等号右边对 $J$ 的求和项目了。公式就简化下面这样：</p><p>$$<br>\begin{aligned}<br>\frac \partial {\partial\theta_j}J(\theta) &amp; &#x3D; \frac \partial {\partial\theta_j} \frac  12(h_\theta(x)-y)^2\<br>&amp; &#x3D; 2 \cdot\frac 12(h_\theta(x)-y)\cdot \frac \partial {\partial\theta_j}  (h_\theta(x)-y) \<br>&amp; &#x3D; (h_\theta(x)-y)\cdot \frac \partial {\partial\theta_j}(\sum^n_{i&#x3D;0} \theta_ix_i-y) \<br>&amp; &#x3D; (h_\theta(x)-y) x_j<br>\end{aligned}<br>$$</p><p>对单个训练样本，更新规则如下所示：</p><p>$$<br>\theta_j :&#x3D; \theta_j + \alpha (y^{(i)}-h_\theta (x^{(i)}))x_j^{(i)}<br>$$</p><p>第一种就是下面这个算法：</p><p>$<br>\begin{aligned}<br>&amp;\qquad 重复直到收敛 { \<br>&amp;\qquad\qquad\theta_j :&#x3D; \theta_j + \alpha \sum^m_{i&#x3D;1}(y^{(i)}-h_\theta (x^{(i)}))x_j^{(i)}\quad(对每个j) \<br>&amp;\qquad}<br>\end{aligned}<br>$</p><p>读者很容易能证明，在上面这个更新规则中求和项的值就是$\frac {\partial J(\theta)}{\partial \theta_j}$ （这是因为对 $J$ 的原始定义）。所以这个更新规则实际上就是对原始的成本函数 $J $进行简单的梯度下降。这一方法在每一个步长内检查所有整个训练集中的所有样本，也叫做<strong>批量梯度下降法（batch gradient descent</strong>）。这里要注意，因为梯度下降法容易被局部最小值影响，而我们要解决的这个线性回归的优化问题只能有一个全局的而不是局部的最优解；因此，梯度下降法应该总是收敛到全局最小值（假设学习速率 $\alpha$ 不设置的过大）。</p><p>对咱们之前的房屋数据集进行批量梯度下降来拟合 $\theta$ ，把房屋价格当作房屋面积的函数来进行预测，我们得到的结果是 $\theta_0 &#x3D; 71.27, \theta_1 &#x3D; 0.1345$。如果把 $h_{\theta}(x)$ 作为一个定义域在 $x$ 上的函数来投影，同时也投上训练集中的已有数据点，会得到下面这幅图：</p><p><img src="/./image/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/3.png"></p><p>如果在数据集中添加上卧室数目作为输入特征，那么得到的结果就是 $\theta_0 &#x3D; 89.60, \theta_1 &#x3D; 0.1392, \theta_2 &#x3D; −8.738$​。这个结果就是用批量梯度下降法来获得的。</p><p>此外还有另外一种方法能够替代批量梯度下降法，这种方法效果也不错。如下所示：</p><p>$<br>\begin{aligned}<br>&amp;\qquad循环：{ \<br>&amp;\qquad\qquad i从1到m,{   \<br>&amp;\qquad\qquad\qquad\theta_j :&#x3D; \theta_j  +\alpha(y^{(i)}-h_{\theta}(x^{(i)}))x_j^{(i)} \qquad(对每个 j) \<br>&amp;\qquad\qquad}  \<br>&amp;\qquad}<br>\end{aligned}<br>$</p><p>在这个算法里，我们对整个训练集进行了循环遍历，每次遇到一个训练样本，根据每个单一训练样本的误差梯度来对参数进行更新。这个算法叫做<strong>随机梯度下降法（stochastic gradient descent）</strong>，或者叫<strong>增量梯度下降法（incremental gradient descent）</strong>。批量梯度下降法要在运行第一步之前先对整个训练集进行扫描遍历，当训练集的规模 $m$ 变得很大的时候，引起的性能开销就很不划算了；随机梯度下降法就没有这个问题，而是可以立即开始，对查询到的每个样本都进行运算。通常情况下，随机梯度下降法查找到足够接近最低值的 $\theta$ 的速度要比批量梯度下降法更快一些。（也要注意，也有可能会一直无法收敛（converge）到最小值，这时候 $\theta$ 会一直在 $J(\theta)$ 最小值附近震荡；不过通常情况下在最小值附近的这些值大多数其实也足够逼近了，足以满足咱们的精度要求，所以也可以用。）由于这些原因，特别是在训练集很大的情况下，随机梯度下降往往比批量梯度下降更受青睐。</p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/04/24/hello-world/"/>
    <url>/2022/04/24/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
