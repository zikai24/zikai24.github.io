<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>NLP-Stanford_CS224N</title>
    <link href="/2022/05/01/NLP-Stanford-CS224N/"/>
    <url>/2022/05/01/NLP-Stanford-CS224N/</url>
    
    <content type="html"><![CDATA[<h1 id="nlp">NLP</h1><h2 id="introduction-and-word-vectors">1、Introduction and WordVectors</h2><h3 id="word-vectors">Word Vectors</h3><p>We will build a dense vector for each word, chosen so that it issimilar to vectors of words that appear in similar contexts.</p><p><img src="/img/nlp/1.png" /></p><p>Note: word vectors are also called word embeddings or (neural) wordrepresentations. They are a distributed representation.</p><p><img src="/img/nlp/2.png" /></p><h3 id="word2vec">Word2vec</h3><p>Word2vec (Mikolov et al. 2013) is a framework for learning wordvectors</p><p>Idea:</p><ul><li>We have a large corpus (“body”) of text</li><li>Every word in a fixed vocabulary is represented by a vector</li><li>Go through each position t in the text, which has a center word cand context (“outside”) words o</li><li>Use the similarity of the word vectors for c and o to calculate theprobability of o given c (or vice versa)</li><li>Keep adjusting the word vectors to maximize this probability</li></ul><p><img src="/img/nlp/3.png" /></p><p>For each position t = 1, … , ), predict context words within a windowof fixed size m, given center word<spanclass="math inline">\(w_j\)</span>​​​. Data likelihood <spanclass="math display">\[Likelihood = L(\theta) = \prod_{t=1}^{T} \prod_{\substack{-m \leq j \leqm \\ j \neq 0}}P(w_{t+j}|w_t;\theta)\]</span></p><p>The objective function <span class="math inline">\(J(\theta)\)</span>​​​​(sometimes called a cost and loss function)is the (average) negative loglikelihood <span class="math display">\[Likelihood=-\frac1T \log L(\theta)=-\frac1T \sum_{t=1}^{T}\sum_{\substack{-m \leq j \leq m \\ j \neq 0}} \logP(w_{t+j}|w_t;\theta)\]</span></p><p>Minimizing objective function ⟺ Maximizing predictive accuracy</p>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>双指针</title>
    <link href="/2022/05/01/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <url>/2022/05/01/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h2 id="盛水最多的容器">11、盛水最多的容器</h2><p><img src="/img/LeetCode/数组及数学/3.png" /></p><p>我们使用双指针的思想，两个指针分别为数组的头尾结点，每轮都进行面积的计算，并且每轮只移动较小结点的指针。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxArea</span>(<span class="hljs-params">self, height: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(height)<br>        left = <span class="hljs-number">0</span>    <span class="hljs-comment"># 左指针</span><br>        right = n - <span class="hljs-number">1</span>   <span class="hljs-comment"># 右指针</span><br>        max_s = <span class="hljs-number">0</span>   <span class="hljs-comment"># 面积最大值</span><br>        s = <span class="hljs-number">0</span>   <span class="hljs-comment"># 面积</span><br>        l = <span class="hljs-number">0</span>   <span class="hljs-comment"># 边长</span><br>        <span class="hljs-keyword">while</span> right &gt; left:<br>            <span class="hljs-keyword">if</span> height[left] &gt; height[right]:<br>                l = height[right]<br>            <span class="hljs-keyword">else</span>:<br>                l = height[left]<br>            s = (right - left) * l<br>            <span class="hljs-keyword">if</span> s &gt; max_s:<br>                max_s = s<br>            <span class="hljs-keyword">if</span> height[left] &gt; height[right]:<br>                right = right - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                left = left + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> max_s<br></code></pre></div></td></tr></table></figure><h2 id="三数之和">15、三数之和</h2><p><img src="/img/LeetCode/数组及数学/15.png" /></p><p>采用双指针的思想，为了不使三元组重复，先对数组进行排序。当确定了第一个元素，只需要对剩下元素进行设置左指针和右指针，如果三元组大与0，右指针就左移一位，反之亦然。如果三元组之和刚好等于0，就需要左指针和右指针都移动一位。这时候还会出现重复问题，所以需要判断此时遍历的元素和之前的是否相同，如果相同就要跳过。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">threeSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        nums.sort()<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        ans = <span class="hljs-built_in">list</span>()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<span class="hljs-comment"># 固定其中一个元素</span><br>            <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> nums[i] != nums[i - <span class="hljs-number">1</span>]:<br>                k = n - <span class="hljs-number">1</span><br>                j = i + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">while</span> k &gt; j:<span class="hljs-comment"># 进行双指针遍历</span><br>                    <span class="hljs-keyword">if</span> k != n - <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> nums[k] == nums[k + <span class="hljs-number">1</span>]:<span class="hljs-comment"># 如果右指针之前出现过就跳过</span><br>                        k = k - <span class="hljs-number">1</span><br>                        <span class="hljs-keyword">continue</span><br>                    <span class="hljs-keyword">if</span> j != i + <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> nums[j] == nums[j - <span class="hljs-number">1</span>]:<span class="hljs-comment"># 如果左指针之前出现过就跳过</span><br>                        j = j + <span class="hljs-number">1</span><br>                        <span class="hljs-keyword">continue</span><br>                    s = nums[i] + nums[j] + nums[k]<br>                    <span class="hljs-keyword">if</span> s == <span class="hljs-number">0</span>:<br>                        ans.append([nums[i], nums[j], nums[k]])<br>                        k = k - <span class="hljs-number">1</span><br>                        j = j + <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">elif</span> s &gt; <span class="hljs-number">0</span>:<br>                        k = k - <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">elif</span> s &lt; <span class="hljs-number">0</span>:<br>                        j = j + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></div></td></tr></table></figure><h2 id="最接近的三数之和">16、最接近的三数之和</h2><p><img src="/img/LeetCode/数组及数学/16.png" /></p><p>采用双指针的思想，先对数组进行排序。当确定了第一个元素，只需要对剩下元素进行设置左指针和右指针，如果三元组之和大于target，我们只需要将右节点左移一位，相反亦然。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">threeSumClosest</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        nums.sort()<br>        min_num = <span class="hljs-number">10</span>**<span class="hljs-number">9</span><br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> i != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i] == nums[i - <span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">continue</span><br>            k = n - <span class="hljs-number">1</span><br>            j = i + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> k &gt; j:<br>                s = nums[i] + nums[j] + nums[k]<br>                <span class="hljs-keyword">if</span> s == target:<br>                    <span class="hljs-keyword">return</span> s<br>                <span class="hljs-keyword">if</span> s &gt; target:<br>                    <span class="hljs-keyword">if</span> s - target &lt; min_num:<br>                        min_num = s - target<br>                        ans = s<br>                    k = k - <span class="hljs-number">1</span><br>                <span class="hljs-keyword">elif</span> s &lt; target:<br>                    <span class="hljs-keyword">if</span> target - s &lt; min_num:<br>                        min_num = target - s<br>                        ans = s<br>                    j = j + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2022/04/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2022/04/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h2 id="最长回文子串">4、最长回文子串</h2><p><img src="/img/LeetCode/字符串/2.png" /></p><p>本题使用的动态规划的思想，也就是说只有s[i+1:j-1]<em>s</em>[<em>i</em>+1:<em>j</em>−1] 是回文串，并且s<em>s</em> 的第 i<em>i</em> 和 j<em>j</em>个字母相同时，s[i:j]<em>s</em>[<em>i</em>:<em>j</em>] 才会是回文串。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        n = <span class="hljs-built_in">len</span>(s)<br>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span>:  <span class="hljs-comment"># 如果字符串长为1</span><br>            <span class="hljs-keyword">return</span> s<br>        <br>        <span class="hljs-built_in">max</span> = <span class="hljs-number">1</span><br>        left = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># dp[i][j]代表是s[i...j]是否为回文串</span><br>        dp = [[<span class="hljs-literal">False</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            dp[i][i] = <span class="hljs-literal">True</span><br><br>        <span class="hljs-keyword">for</span> L <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                right = L + i - <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> right &gt;= n:<br>                    <span class="hljs-keyword">break</span><br>                <br>                <span class="hljs-keyword">if</span> s[i] != s[right]:<br>                    dp[i][right] = <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">if</span> right - i &lt; <span class="hljs-number">3</span>:<br>                        dp[i][right] = <span class="hljs-literal">True</span><br>                    <span class="hljs-keyword">else</span>:<br>                        dp[i][right] = dp[i + <span class="hljs-number">1</span>][right - <span class="hljs-number">1</span>]<br><br>                <span class="hljs-keyword">if</span> dp[i][right] <span class="hljs-keyword">and</span> L &gt; <span class="hljs-built_in">max</span>:<br>                    <span class="hljs-built_in">max</span> = L<br>                    left = i<br>        <span class="hljs-keyword">return</span> s[left:left+<span class="hljs-built_in">max</span>]<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>字符串</title>
    <link href="/2022/04/29/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/04/29/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="无重复字符的最长子串">3、无重复字符的最长子串</h2><p><img src="/img/LeetCode/字符串/1.png" /></p><p>方法一：暴力解</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        occ = <span class="hljs-built_in">set</span>()<br>        n = <span class="hljs-built_in">len</span>(s)<br>        <span class="hljs-comment"># rk为左指针，ans为无重复子串长度</span><br>        rk, ans = -<span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>        flag = <span class="hljs-number">0</span>    <span class="hljs-comment"># 循环中无重复子串长度</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            rk = i<br>            flag = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">while</span> rk &lt; n <span class="hljs-keyword">and</span> s[rk] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> occ:<br>                occ.add(s[rk])<br>                flag = flag + <span class="hljs-number">1</span><br>                rk = rk + <span class="hljs-number">1</span><br>            ans = flag <span class="hljs-keyword">if</span> flag &gt; ans <span class="hljs-keyword">else</span> ans<br>            occ.clear()<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></div></td></tr></table></figure><p>方法二：</p><p>每次循环没必要把集合里的元素全部删除，可以每次只删除上一轮循环的最左边结点</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        occ = <span class="hljs-built_in">set</span>()<br>        n = <span class="hljs-built_in">len</span>(s)<br>        <span class="hljs-comment"># rk为左指针，ans为无重复子串长度</span><br>        rk, ans = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        flag = <span class="hljs-number">0</span>    <span class="hljs-comment"># 循环中无重复子串长度</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span>:<br>                occ.remove(s[i - <span class="hljs-number">1</span>])<br>                flag = flag - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> rk &lt; n <span class="hljs-keyword">and</span> s[rk] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> occ:<br>                occ.add(s[rk])<br>                rk = rk + <span class="hljs-number">1</span><br>                flag = flag + <span class="hljs-number">1</span><br>            ans = flag <span class="hljs-keyword">if</span> flag &gt; ans <span class="hljs-keyword">else</span> ans<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></div></td></tr></table></figure><h2 id="最长回文子串">4、最长回文子串</h2><p><img src="/img/LeetCode/字符串/2.png" /></p><p>本题使用的动态规划的思想，也就是说只有s[i+1:j-1]<em>s</em>[<em>i</em>+1:<em>j</em>−1] 是回文串，并且s<em>s</em> 的第 i<em>i</em> 和 j<em>j</em>个字母相同时，s[i:j]<em>s</em>[<em>i</em>:<em>j</em>] 才会是回文串。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        n = <span class="hljs-built_in">len</span>(s)<br>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span>:  <span class="hljs-comment"># 如果字符串长为1</span><br>            <span class="hljs-keyword">return</span> s<br>        <br>        <span class="hljs-built_in">max</span> = <span class="hljs-number">1</span><br>        left = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># dp[i][j]代表是s[i...j]是否为回文串</span><br>        dp = [[<span class="hljs-literal">False</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            dp[i][i] = <span class="hljs-literal">True</span><br><br>        <span class="hljs-keyword">for</span> L <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                right = L + i - <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> right &gt;= n:<br>                    <span class="hljs-keyword">break</span><br>                <br>                <span class="hljs-keyword">if</span> s[i] != s[right]:<br>                    dp[i][right] = <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">if</span> right - i &lt; <span class="hljs-number">3</span>:<br>                        dp[i][right] = <span class="hljs-literal">True</span><br>                    <span class="hljs-keyword">else</span>:<br>                        dp[i][right] = dp[i + <span class="hljs-number">1</span>][right - <span class="hljs-number">1</span>]<br><br>                <span class="hljs-keyword">if</span> dp[i][right] <span class="hljs-keyword">and</span> L &gt; <span class="hljs-built_in">max</span>:<br>                    <span class="hljs-built_in">max</span> = L<br>                    left = i<br>        <span class="hljs-keyword">return</span> s[left:left+<span class="hljs-built_in">max</span>]<br></code></pre></div></td></tr></table></figure><h2 id="z字形变换">6、Z字形变换</h2><p><img src="/img/LeetCode/字符串/3.png" /></p><p>使用二维矩阵进行模拟：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">convert</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, numRows: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        n = <span class="hljs-built_in">len</span>(s)<br>        <span class="hljs-keyword">if</span> numRows == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> numRows &gt;= n:<br>            <span class="hljs-keyword">return</span> s<br>        t = <span class="hljs-number">2</span> * numRows - <span class="hljs-number">2</span><br>        col = (n + t - <span class="hljs-number">1</span>) // t * (numRows - <span class="hljs-number">1</span>)<br>        matrix = [[<span class="hljs-string">&#x27;&#x27;</span>] * col <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numRows)]<br>        x, y = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i, ch <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            matrix[x][y] = ch<br>            <span class="hljs-keyword">if</span> i % t &lt; numRows - <span class="hljs-number">1</span>:<br>                x = x + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                x = x - <span class="hljs-number">1</span><br>                y = y + <span class="hljs-number">1</span><br>        ans = <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numRows):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(col):<br>                <span class="hljs-keyword">if</span> matrix[i][j]:<br>                    ans = ans + matrix[i][j]<br><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></div></td></tr></table></figure><h2 id="字符串转换整数">7、字符串转换整数</h2><p><img src="/img/LeetCode/字符串/4.png" /></p><p><img src="/img/LeetCode/字符串/5.png" /></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">myAtoi</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        flag = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">if</span> s == <span class="hljs-string">&#x27;&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i, ch <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            <span class="hljs-keyword">if</span> ch != <span class="hljs-string">&#x27; &#x27;</span>:<br>                s = s[i:]<br>                <span class="hljs-keyword">break</span><br><br>        <span class="hljs-keyword">if</span> s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>:<br>            flag = <span class="hljs-literal">True</span><br>            s = s[<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">elif</span> s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;+&#x27;</span>:<br>            s = s[<span class="hljs-number">1</span>:]<br>        a = <span class="hljs-number">0</span><br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i, ch <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            <span class="hljs-keyword">if</span> ch.isdigit() == <span class="hljs-literal">False</span>:<br>                <span class="hljs-keyword">break</span><br>            a = <span class="hljs-built_in">int</span>(ch)<br>            ans = ans * <span class="hljs-number">10</span> + a<br>        <span class="hljs-keyword">if</span> flag:<br>            ans = -<span class="hljs-number">1</span> * ans<br>        <span class="hljs-keyword">if</span> ans &gt; <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> ans &lt; -(<span class="hljs-number">2</span> ** <span class="hljs-number">31</span>):<br>            <span class="hljs-keyword">return</span> -(<span class="hljs-number">2</span> ** <span class="hljs-number">31</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> ans<br></code></pre></div></td></tr></table></figure><h2 id="最长公共前缀">14、最长公共前缀</h2><p><img src="/img/LeetCode/字符串/6.png" /></p><p>想法为横向对比，按照列表顺序开始逐步算法前x个字符串的最长前缀，直至得到最终的最长前缀</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestCommonPrefix</span>(<span class="hljs-params">self, strs: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">str</span>:<br>        flag = strs[<span class="hljs-number">0</span>]<span class="hljs-comment"># 前几个字符串的最长前缀</span><br>        a = <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment"># 本字符串与flag的最长前缀</span><br>        ans = <span class="hljs-string">&quot;&quot;</span><br>        n = <span class="hljs-built_in">len</span>(strs)<br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<span class="hljs-comment"># 如果只有一个字符串，那就直接输出</span><br>            <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i, s <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(strs):<br>            <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:<span class="hljs-comment"># 如果是第一个字符串那就跳过</span><br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">for</span> j, ch <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<span class="hljs-comment"># 本字符串与flag进行比对</span><br>                <span class="hljs-keyword">if</span> j &lt; <span class="hljs-built_in">len</span>(flag) <span class="hljs-keyword">and</span> ch == flag[j]:<br>                    a = a + ch<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">break</span><br>            flag = a<br>            a = <span class="hljs-string">&quot;&quot;</span><br>            <span class="hljs-keyword">if</span> i == n - <span class="hljs-number">1</span>:<span class="hljs-comment"># 如果是最后一个结点，那就是最终最长前缀了</span><br>                ans = flag<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>哈希表</title>
    <link href="/2022/04/28/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <url>/2022/04/28/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="两数相加">1、两数相加</h2><p><img src="/img/LeetCode/哈希表/1.png" /></p><p>这样我们创建一个哈希表，对于每一个<code>x</code>，我们首先查询哈希表中是否存在<code>target - x</code>，然后将 <code>x</code>插入到哈希表中，即可保证不会让 <code>x</code> 和自己匹配。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        hashtable = <span class="hljs-built_in">dict</span>()<br>        <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            <span class="hljs-keyword">if</span> target - num <span class="hljs-keyword">in</span> hashtable:<br>                <span class="hljs-keyword">return</span> [hashtable[target - num], i]<br>            <span class="hljs-keyword">else</span>:<br>                hashtable[num] = i<br>        <span class="hljs-keyword">return</span> []<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2022/04/28/%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/04/28/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="两数相加">2、两数相加</h2><p><img src="/img/LeetCode/链表/2.png" /></p><p>采用递归的思想，当某个链表当前节点存在下一个节点或进位符为1时，往下递归。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.next = next</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addTwoNumbers</span>(<span class="hljs-params">self, l1: <span class="hljs-type">Optional</span>[ListNode], l2: <span class="hljs-type">Optional</span>[ListNode], carryflag = <span class="hljs-number">0</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        n1, n2 = l1.val <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>, l2.val <span class="hljs-keyword">if</span> l2 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>        s = n1 + n2 + carryflag<br>        val, carry_flag = s % <span class="hljs-number">10</span>, <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> s &gt; <span class="hljs-number">9</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>        next1, next2 = l1.<span class="hljs-built_in">next</span> <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>, l2.<span class="hljs-built_in">next</span> <span class="hljs-keyword">if</span> l2 <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">if</span> next1 <span class="hljs-keyword">or</span> next2 <span class="hljs-keyword">or</span> carry_flag:<br>            <span class="hljs-keyword">return</span> ListNode(val, self.addTwoNumbers(next1, next2, carry_flag))<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> ListNode(val)<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数组及数学</title>
    <link href="/2022/04/28/%E6%95%B0%E7%BB%84%E5%8F%8A%E6%95%B0%E5%AD%A6/"/>
    <url>/2022/04/28/%E6%95%B0%E7%BB%84%E5%8F%8A%E6%95%B0%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="整数反转">7、整数反转</h2><p><img src="/img/LeetCode/数组及数学/1.png" /></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ans = <span class="hljs-number">0</span><br>        flag = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span>:<br>            flag = <span class="hljs-literal">True</span><br>            x = -<span class="hljs-number">1</span> * x<br>        a = <span class="hljs-number">0</span>   <span class="hljs-comment"># 除法余数</span><br>        <span class="hljs-keyword">while</span> x != <span class="hljs-number">0</span>:<br>            a = x % <span class="hljs-number">10</span><br>            x = x // <span class="hljs-number">10</span><br>            ans = ans * <span class="hljs-number">10</span> + a<br>        <span class="hljs-keyword">if</span> flag:<br>            ans = -<span class="hljs-number">1</span> * ans<br>        <span class="hljs-keyword">if</span> ans &gt; <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> ans &lt; -(<span class="hljs-number">2</span> ** <span class="hljs-number">31</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> ans<br></code></pre></div></td></tr></table></figure><h2 id="回文数">9、回文数</h2><p><img src="/img/LeetCode/数组及数学/2.png" /></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isPalindrome</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        a = self.reverse(x) <span class="hljs-comment"># 整数反转</span><br>        <span class="hljs-keyword">if</span> a == x:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ans = <span class="hljs-number">0</span><br>        a = <span class="hljs-number">0</span>   <span class="hljs-comment"># 除法余数</span><br>        <span class="hljs-keyword">while</span> x != <span class="hljs-number">0</span>:<br>            a = x % <span class="hljs-number">10</span><br>            x = x // <span class="hljs-number">10</span><br>            ans = ans * <span class="hljs-number">10</span> + a<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></div></td></tr></table></figure><h2 id="盛水最多的容器">11、盛水最多的容器</h2><p><img src="/img/LeetCode/数组及数学/3.png" /></p><p>我们使用双指针的思想，两个指针分别为数组的头尾结点，每轮都进行面积的计算，并且每轮只移动较小结点的指针。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxArea</span>(<span class="hljs-params">self, height: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(height)<br>        left = <span class="hljs-number">0</span>    <span class="hljs-comment"># 左指针</span><br>        right = n - <span class="hljs-number">1</span>   <span class="hljs-comment"># 右指针</span><br>        max_s = <span class="hljs-number">0</span>   <span class="hljs-comment"># 面积最大值</span><br>        s = <span class="hljs-number">0</span>   <span class="hljs-comment"># 面积</span><br>        l = <span class="hljs-number">0</span>   <span class="hljs-comment"># 边长</span><br>        <span class="hljs-keyword">while</span> right &gt; left:<br>            <span class="hljs-keyword">if</span> height[left] &gt; height[right]:<br>                l = height[right]<br>            <span class="hljs-keyword">else</span>:<br>                l = height[left]<br>            s = (right - left) * l<br>            <span class="hljs-keyword">if</span> s &gt; max_s:<br>                max_s = s<br>            <span class="hljs-keyword">if</span> height[left] &gt; height[right]:<br>                right = right - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                left = left + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> max_s<br></code></pre></div></td></tr></table></figure><h2 id="整数转罗马数字">12、整数转罗马数字</h2><p><img src="/img/LeetCode/数组及数学/4.png" /></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    A = [<br>        (<span class="hljs-number">1000</span>, <span class="hljs-string">&quot;M&quot;</span>),<br>        (<span class="hljs-number">900</span>, <span class="hljs-string">&quot;CM&quot;</span>),<br>        (<span class="hljs-number">500</span>, <span class="hljs-string">&quot;D&quot;</span>),<br>        (<span class="hljs-number">400</span>, <span class="hljs-string">&quot;CD&quot;</span>),<br>        (<span class="hljs-number">100</span>, <span class="hljs-string">&quot;C&quot;</span>),<br>        (<span class="hljs-number">90</span>, <span class="hljs-string">&quot;XC&quot;</span>),<br>        (<span class="hljs-number">50</span>, <span class="hljs-string">&quot;L&quot;</span>),<br>        (<span class="hljs-number">40</span>, <span class="hljs-string">&quot;XL&quot;</span>),<br>        (<span class="hljs-number">10</span>, <span class="hljs-string">&quot;X&quot;</span>),<br>        (<span class="hljs-number">9</span>, <span class="hljs-string">&quot;IX&quot;</span>),<br>        (<span class="hljs-number">5</span>, <span class="hljs-string">&quot;V&quot;</span>),<br>        (<span class="hljs-number">4</span>, <span class="hljs-string">&quot;IV&quot;</span>),<br>        (<span class="hljs-number">1</span>, <span class="hljs-string">&quot;I&quot;</span>),<br>    ]<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">intToRoman</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        ans = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">for</span> value, s <span class="hljs-keyword">in</span> self.A:<br>            <span class="hljs-keyword">while</span> num &gt;= value:<br>                num = num - value<br>                ans = ans + s<br>            <span class="hljs-keyword">if</span> num == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">break</span><br>        <br>        <span class="hljs-keyword">return</span> ans<br></code></pre></div></td></tr></table></figure><h2 id="罗马数字转整数">13、罗马数字转整数</h2><p><img src="/img/LeetCode/数组及数学/5.png" /></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    A = &#123;<br>        <span class="hljs-string">&#x27;I&#x27;</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-string">&#x27;V&#x27;</span>: <span class="hljs-number">5</span>,<br>        <span class="hljs-string">&#x27;X&#x27;</span>: <span class="hljs-number">10</span>,<br>        <span class="hljs-string">&#x27;L&#x27;</span>: <span class="hljs-number">50</span>,<br>        <span class="hljs-string">&#x27;C&#x27;</span>: <span class="hljs-number">100</span>,<br>        <span class="hljs-string">&#x27;D&#x27;</span>: <span class="hljs-number">500</span>,<br>        <span class="hljs-string">&#x27;M&#x27;</span>: <span class="hljs-number">1000</span>,<br>    &#125;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">romanToInt</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ans = <span class="hljs-number">0</span><br>        n = <span class="hljs-built_in">len</span>(s)<br>        <span class="hljs-keyword">for</span> i, ch <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            <span class="hljs-keyword">if</span> i &lt; n - <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> self.A[ch] &lt; self.A[s[i+<span class="hljs-number">1</span>]]:<br>                ans = ans - self.A[ch]<br>            <span class="hljs-keyword">else</span>:<br>                ans = ans + self.A[ch]<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></div></td></tr></table></figure><h2 id="三数之和">15、三数之和</h2><p><img src="/img/LeetCode/数组及数学/15.png" /></p><p>采用双指针的思想，为了不使三元组重复，先对数组进行排序。当确定了第一个元素，只需要对剩下元素进行设置左指针和右指针，如果三元组大与0，右指针就左移一位，反之亦然。如果三元组之和刚好等于0，就需要左指针和右指针都移动一位。这时候还会出现重复问题，所以需要判断此时遍历的元素和之前的是否相同，如果相同就要跳过。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">threeSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        nums.sort()<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        ans = <span class="hljs-built_in">list</span>()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<span class="hljs-comment"># 固定其中一个元素</span><br>            <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> nums[i] != nums[i - <span class="hljs-number">1</span>]:<br>                k = n - <span class="hljs-number">1</span><br>                j = i + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">while</span> k &gt; j:<span class="hljs-comment"># 进行双指针遍历</span><br>                    <span class="hljs-keyword">if</span> k != n - <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> nums[k] == nums[k + <span class="hljs-number">1</span>]:<span class="hljs-comment"># 如果右指针之前出现过就跳过</span><br>                        k = k - <span class="hljs-number">1</span><br>                        <span class="hljs-keyword">continue</span><br>                    <span class="hljs-keyword">if</span> j != i + <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> nums[j] == nums[j - <span class="hljs-number">1</span>]:<span class="hljs-comment"># 如果左指针之前出现过就跳过</span><br>                        j = j + <span class="hljs-number">1</span><br>                        <span class="hljs-keyword">continue</span><br>                    s = nums[i] + nums[j] + nums[k]<br>                    <span class="hljs-keyword">if</span> s == <span class="hljs-number">0</span>:<br>                        ans.append([nums[i], nums[j], nums[k]])<br>                        k = k - <span class="hljs-number">1</span><br>                        j = j + <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">elif</span> s &gt; <span class="hljs-number">0</span>:<br>                        k = k - <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">elif</span> s &lt; <span class="hljs-number">0</span>:<br>                        j = j + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></div></td></tr></table></figure><h2 id="最接近的三数之和">16、最接近的三数之和</h2><p><img src="/img/LeetCode/数组及数学/16.png" /></p><p>采用双指针的思想，先对数组进行排序。当确定了第一个元素，只需要对剩下元素进行设置左指针和右指针，如果三元组之和大于target，我们只需要将右节点左移一位，相反亦然。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">threeSumClosest</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        nums.sort()<br>        min_num = <span class="hljs-number">10</span>**<span class="hljs-number">9</span><br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> i != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i] == nums[i - <span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">continue</span><br>            k = n - <span class="hljs-number">1</span><br>            j = i + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> k &gt; j:<br>                s = nums[i] + nums[j] + nums[k]<br>                <span class="hljs-keyword">if</span> s == target:<br>                    <span class="hljs-keyword">return</span> s<br>                <span class="hljs-keyword">if</span> s &gt; target:<br>                    <span class="hljs-keyword">if</span> s - target &lt; min_num:<br>                        min_num = s - target<br>                        ans = s<br>                    k = k - <span class="hljs-number">1</span><br>                <span class="hljs-keyword">elif</span> s &lt; target:<br>                    <span class="hljs-keyword">if</span> target - s &lt; min_num:<br>                        min_num = target - s<br>                        ans = s<br>                    j = j + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pytorch</title>
    <link href="/2022/04/27/pytorch/"/>
    <url>/2022/04/27/pytorch/</url>
    
    <content type="html"><![CDATA[<h1 id="pytorch">PyTorch</h1><h2 id="dataset">1、DataSet</h2><p>DataSet：提供一种方法去获取数据及其label</p><p>使用的数据集为蜜蜂与蚂蚁的图像数据集，分别保存在dataset/train/bees以及dataset/train/ants</p><p>DataSet需要通过继承重载才能使用，使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> Dataset<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyData</span>(<span class="hljs-title class_ inherited__">Dataset</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, root_dir, label_dir</span>):<span class="hljs-comment"># read data &amp; preprocess</span><br>        self.root_dir = root_dir    <span class="hljs-comment"># 根目录</span><br>        self.label_dir = label_dir  <span class="hljs-comment"># 标记目录</span><br>        self.path = os.path.join(self.root_dir, self.label_dir)     <span class="hljs-comment"># 地址相加</span><br>        self.img_path = os.listdir(self.path)   <span class="hljs-comment"># 生成图片文件列表</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, index</span>):<span class="hljs-comment"># returns one sample at a time</span><br>        img_name = self.img_path[index]   <span class="hljs-comment"># 文件名</span><br>        img_item_path = os.path.join(self.root_dir, self.label_dir, img_name)<br>        img = Image.<span class="hljs-built_in">open</span>(img_item_path)<br>        label = self.label_dir<br>        <span class="hljs-keyword">return</span> img, label<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<span class="hljs-comment"># returns the size of the dataset</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.img_path)<br><br><br><span class="hljs-comment"># 读取蚂蚁和蜜蜂的图片数据集</span><br>root_dir = <span class="hljs-string">&quot;dataset/train&quot;</span><br>ants_label_dir = <span class="hljs-string">&quot;ants&quot;</span><br>bees_label_dir = <span class="hljs-string">&quot;bees&quot;</span><br>ants_dataset = MyData(root_dir, ants_label_dir)<br>bees_dataset = MyData(root_dir, bees_label_dir)<br><br><span class="hljs-comment"># 将两个数据集进行合并，成为训练数据集</span><br>train_dataset = ants_dataset + bees_dataset<br></code></pre></div></td></tr></table></figure><h2 id="dataloader">2、DataLoader</h2><p>DataSet就相当于是一整个数据集，而DataLoader是取出其中一部分到神经网络中进行使用。</p><p>使用的是torchvision所提供的数据集。DataLoader中的参数分别释义如下：</p><ul><li>dataset：我们所使用的数据集，即dataset类型数据</li><li>batch_size：一次抓取多少个数据</li><li>shuffle：抓取时是否打乱顺序</li><li>num_workers：代表创建了多少个worker进程，0表示只有主进程去加载batch数据，1表示有一个worker进程加载batch数据</li><li>drop_last：无法整除时，最后剩余的几条数据要不要去除</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><br><span class="hljs-comment"># 准备的测试数据集</span><br><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><br>test_data = torchvision.datasets.CIFAR10(<span class="hljs-string">&quot;./dataset&quot;</span>, train=<span class="hljs-literal">False</span>, transform=torchvision.transforms.ToTensor(), download=<span class="hljs-literal">True</span>)<br><br>test_loader = DataLoader(dataset=test_data, batch_size=<span class="hljs-number">64</span>, shuffle=<span class="hljs-literal">True</span>, num_workers=<span class="hljs-number">0</span>, drop_last=<span class="hljs-literal">False</span>)<br><br>writer = SummaryWriter(<span class="hljs-string">&quot;dataloader&quot;</span>)<br>step = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> test_loader:<br>    imgs, targets = data<br>    writer.add_images(<span class="hljs-string">&quot;test_data&quot;</span>, imgs, step)<br>    step = step + <span class="hljs-number">1</span><br><br>writer.close()<br></code></pre></div></td></tr></table></figure><p>最后显示结果如下：</p><p><img src="/img/pytorch/1.png" /></p><h2 id="tensorboard">3、TensorBoard</h2><p>我们可以通过TensorBoard可以查看图像</p><h3 id="输出函数图像">3.1输出函数图像</h3><p>首先我们通过TensorBoard来绘制y=x的图像，我们需要先生成一个实例，随后通过add_scalar()方法来添加，参数分别为名称，y轴的值，x轴的值。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><br><span class="hljs-comment"># 创建一个实例,存储在logs文件夹下</span><br>writer = SummaryWriter(<span class="hljs-string">&quot;logs&quot;</span>)<br><br><span class="hljs-comment"># y = x图像</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    writer.add_scalar(<span class="hljs-string">&quot;y=x&quot;</span>, i, i)<br><br>writer.close()<br></code></pre></div></td></tr></table></figure><p>完成后，我们可以通过控制台输入如下指令来观看图像</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">tensorboard --logdir=logs<br></code></pre></div></td></tr></table></figure><p>这时候我们可以通过6006端口来查看图像，但是如果有很多tensorboard都要查看呢，我们可以选择自定义端口查看，例如我们要选择6007端口来查看，指令如下：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">tensorboard --logdir=logs --port=6007<br></code></pre></div></td></tr></table></figure><p><img src="/img/pytorch/2.png" /></p><p>这时候我们就可以看到y=x的图像</p><p>如果是y=2x的图像则需要修改代码为：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># y = 2x图像</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    writer.add_scalar(<span class="hljs-string">&quot;y=2x&quot;</span>, <span class="hljs-number">2</span>*i, i)<br></code></pre></div></td></tr></table></figure><h3 id="输出图片">3.2输出图片</h3><p>我们也可以通过TensorBoard来显示我们的图片，通过TensorBoard的add_image()方法，参数分别为名称、图片（需要为tensor类型或者numpy类型）、global_step、类型（因为默认的类型为是（3，H，W）即通道(channel)为3，H为高度，W为宽度），代码如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><br><span class="hljs-comment"># 创建一个实例,存储在logs文件夹下</span><br>writer = SummaryWriter(<span class="hljs-string">&quot;logs&quot;</span>)<br>image_path = <span class="hljs-string">&quot;dataset/train/ants/0013035.jpg&quot;</span><br>img_PIL = Image.<span class="hljs-built_in">open</span>(image_path)<br>img_array = np.array(img_PIL)<br><br>writer.add_image(<span class="hljs-string">&quot;test&quot;</span>, img_array, <span class="hljs-number">1</span>, dataformats=<span class="hljs-string">&#x27;HWC&#x27;</span>)<br><br>writer.close()<br></code></pre></div></td></tr></table></figure><h2 id="神经网络的基本骨架">4、神经网络的基本骨架</h2><p>基本骨架是通过对nn.Module的继承重写实现的，大体实现如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyModel</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, <span class="hljs-built_in">input</span></span>):<br>        output = <span class="hljs-built_in">input</span> + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> output<br><br>res = MyModel()<br>x = torch.tensor(<span class="hljs-number">1.0</span>)<br>output = res(x)<span class="hljs-comment"># 有__call__方法来调用，所以可以直接将x输入，不用我们来调用forward()方法</span><br><span class="hljs-built_in">print</span>(output)<br><br></code></pre></div></td></tr></table></figure><p>最后我们可以看到控制台输出为：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">tensor(2.)<br></code></pre></div></td></tr></table></figure><h2 id="卷积层">5、卷积层</h2><p>首先对于卷积层的学习，要了解卷积层的使用，我们先使用torch.nn.functional中的方法（一般都是使用torch.nn，其对functional进行了封装，这里是为了了解如何卷积）进行学习，首先要对conv2d的stride参数进行了解，stride时计算卷积时移动的步长，我们可以使用代码来了解：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><br><span class="hljs-built_in">input</span> = torch.tensor([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>],<br>                      [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>],<br>                      [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>                      [<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br>                      [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]])<br><br>kernel = torch.tensor([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>],<br>                       [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],<br>                       [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]])<br><br><span class="hljs-built_in">input</span> = torch.reshape(<span class="hljs-built_in">input</span>, (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>))<br>kernel = torch.reshape(kernel, (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>))<br><br>output = F.conv2d(<span class="hljs-built_in">input</span>, kernel, stride=<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(output)<br><br>output2 = F.conv2d(<span class="hljs-built_in">input</span>, kernel, stride=<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(output2)<br></code></pre></div></td></tr></table></figure><p>输出结果为：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">tensor([[[[10, 12, 12],<br>          [18, 16, 16],<br>          [13,  9,  3]]]])<br>tensor([[[[10, 12],<br>          [13,  3]]]])<br></code></pre></div></td></tr></table></figure><p>图示为：</p><p><img src="/img/pytorch/4.png" /></p><p>随后我们要学习的是conv2d中的padding参数，它是对输入图像的周围进行填充，并设置填充值：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">output3 = F.conv2d(<span class="hljs-built_in">input</span>, kernel, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(output3)<br></code></pre></div></td></tr></table></figure><p>输出结果为：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">tensor([[[[ 1,  3,  4, 10,  8],<br>          [ 5, 10, 12, 12,  6],<br>          [ 7, 18, 16, 16,  8],<br>          [11, 13,  9,  3,  4],<br>          [14, 13,  9,  7,  4]]]])<br></code></pre></div></td></tr></table></figure><p>图示为：</p><p><img src="/img/pytorch/5.png" /></p><p>现在对卷积层的知识进行了学习后正式来时学习卷积层是如何搭建的，我们要使用的是torch.nn中的conv2d方法，其方法的参数解释在官方文档中如下：</p><ul><li><strong>in_channels</strong> (<ahref="https://docs.python.org/3/library/functions.html#int"><em>int</em></a>)– Number of channels in the input image</li><li><strong>out_channels</strong> (<ahref="https://docs.python.org/3/library/functions.html#int"><em>int</em></a>)– Number of channels produced by the convolution</li><li><strong>kernel_size</strong> (<ahref="https://docs.python.org/3/library/functions.html#int"><em>int</em></a><em>or</em> <ahref="https://docs.python.org/3/library/stdtypes.html#tuple"><em>tuple</em></a>)– Size of the convolving kernel</li><li><strong>stride</strong> (<ahref="https://docs.python.org/3/library/functions.html#int"><em>int</em></a><em>or</em> <ahref="https://docs.python.org/3/library/stdtypes.html#tuple"><em>tuple</em></a><em>,</em><em>optional</em>) – Stride of the convolution. Default: 1</li><li><strong>padding</strong> (<ahref="https://docs.python.org/3/library/functions.html#int"><em>int</em></a><em>,</em><ahref="https://docs.python.org/3/library/stdtypes.html#tuple"><em>tuple</em></a><em>or</em> <ahref="https://docs.python.org/3/library/stdtypes.html#str"><em>str</em></a><em>,</em><em>optional</em>) – Padding added to all four sides of the input.Default: 0</li><li><strong>padding_mode</strong> (*string**,* <em>optional</em>) –<code>'zeros'</code>, <code>'reflect'</code>, <code>'replicate'</code>or <code>'circular'</code>. Default: <code>'zeros'</code></li><li><strong>dilation</strong> (<ahref="https://docs.python.org/3/library/functions.html#int"><em>int</em></a><em>or</em> <ahref="https://docs.python.org/3/library/stdtypes.html#tuple"><em>tuple</em></a><em>,</em><em>optional</em>) – Spacing between kernel elements. Default: 1</li><li><strong>groups</strong> (<ahref="https://docs.python.org/3/library/functions.html#int"><em>int</em></a><em>,</em><em>optional</em>) – Number of blocked connections from input channelsto output channels. Default: 1</li><li><strong>bias</strong> (<ahref="https://docs.python.org/3/library/functions.html#bool"><em>bool</em></a><em>,</em><em>optional</em>) – If <code>True</code>, adds a learnable bias to theoutput. Default: <code>True</code></li></ul><p><img src="/img/pytorch/3.png" /></p><p>我们简单的对图像进行卷积处理：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> torch.nn <span class="hljs-keyword">import</span> Conv2d<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><br>test_data = torchvision.datasets.CIFAR10(<span class="hljs-string">&quot;./dataset&quot;</span>, train=<span class="hljs-literal">False</span>, transform=torchvision.transforms.ToTensor(),<br>                                         download=<span class="hljs-literal">True</span>)<br>dataloader = DataLoader(dataset=test_data, batch_size=<span class="hljs-number">64</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyModel</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(MyModel, self).__init__()<br>        self.conv1 = Conv2d(in_channels=<span class="hljs-number">3</span>, out_channels=<span class="hljs-number">6</span>, kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = self.conv1(x)<br>        <span class="hljs-keyword">return</span> x<br><br><br>myModel = MyModel()<br><br>writer = SummaryWriter(<span class="hljs-string">&quot;logs&quot;</span>)<br>step = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> dataloader:<br>    imgs, targets = data<br>    output = myModel(imgs)<br>    <span class="hljs-comment"># print(imgs.shape)</span><br>    <span class="hljs-comment"># print(output.shape)</span><br><br>    <span class="hljs-comment"># torch.Size([64, 3, 32, 32])</span><br>    writer.add_images(<span class="hljs-string">&quot;input&quot;</span>, imgs, step)<br>    <span class="hljs-comment"># torch.Size([64, 6, 32, 32]) -&gt; [xxx, 3, 32, 32]，因为out_channels为6没办法add进去</span><br>    output = torch.reshape(output, (-<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">30</span>, <span class="hljs-number">30</span>))<br>    writer.add_images(<span class="hljs-string">&quot;output&quot;</span>, output, step)<br><br>    step = step + <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><p>运行结果在tensorboard上显示为：</p><p><img src="/img/pytorch/6.png" /></p><p><img src="/img/pytorch/7.png" /></p><h2 id="池化层">6、池化层</h2><p>我们要使用的是torch.nn中的MaxPool2d方法，其中参数解释为：</p><ul><li><strong>kernel_size</strong> – the size of the window to take a maxover</li><li><strong>stride</strong> – the stride of the window. Default value is<code>kernel_size</code></li><li><strong>padding</strong> – implicit zero padding to be added on bothsides</li><li><strong>dilation</strong> – a parameter that controls the stride ofelements in the window</li><li><strong>return_indices</strong> – if <code>True</code>, will returnthe max indices along with the outputs. Useful for <ahref="https://pytorch.org/docs/stable/generated/torch.nn.MaxUnpool2d.html#torch.nn.MaxUnpool2d"><code>torch.nn.MaxUnpool2d</code></a>later</li><li><strong>ceil_mode</strong> – when True, will use ceil instead offloor to compute the output shape</li></ul><p>对于ceil_mode的两种情况如下图示意：</p><p><img src="/img/pytorch/8.png" /></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> torch.nn <span class="hljs-keyword">import</span> MaxPool2d<br><br><span class="hljs-built_in">input</span> = torch.tensor([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>],<br>                      [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>],<br>                      [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>                      [<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br>                      [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]], dtype=torch.float32)<br><span class="hljs-built_in">input</span> = torch.reshape(<span class="hljs-built_in">input</span>, (-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>))<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyModel</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(MyModel, self).__init__()<br>        self.maxpool1 = MaxPool2d(kernel_size=<span class="hljs-number">3</span>, ceil_mode=<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, <span class="hljs-built_in">input</span></span>):<br>        output = self.maxpool1(<span class="hljs-built_in">input</span>)<br>        <span class="hljs-keyword">return</span> output<br><br><br>myModel = MyModel()<br>output = myModel(<span class="hljs-built_in">input</span>)<br><span class="hljs-built_in">print</span>(output)<br></code></pre></div></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">tensor([[[[2., 3.],<br>          [5., 1.]]]])<br></code></pre></div></td></tr></table></figure><p>当我们将ceil_mode修改为False后：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">self.maxpool1 = MaxPool2d(kernel_size=<span class="hljs-number">3</span>, ceil_mode=<span class="hljs-literal">False</span>)<br></code></pre></div></td></tr></table></figure><p>结果为：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">tensor([[[[2.]]]])<br></code></pre></div></td></tr></table></figure><p>我们可以直观的感受一下最大池化后的结果，我们可以将输入换成我们的数据集，在tensorboard上查看输入输出的差别：</p><p><img src="/img/pytorch/9.png" /></p><h2 id="非线性激活">7、非线性激活</h2><p>首先我们要使用的是torch.nn中的ReLU方法</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> torch.nn <span class="hljs-keyword">import</span> ReLU<br><br><span class="hljs-built_in">input</span> = torch.tensor([[<span class="hljs-number">1</span>, -<span class="hljs-number">0.5</span>],<br>                      [-<span class="hljs-number">1</span>, <span class="hljs-number">3</span>]])<br><br><span class="hljs-built_in">input</span> = torch.reshape(<span class="hljs-built_in">input</span>, (-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>))<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyModel</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(MyModel, self).__init__()<br>        self.relu1 = ReLU()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, <span class="hljs-built_in">input</span></span>):<br>        output = self.relu1(<span class="hljs-built_in">input</span>)<br>        <span class="hljs-keyword">return</span> output<br><br><br>myModel = MyModel()<br>output = myModel(<span class="hljs-built_in">input</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">input</span>)<br><span class="hljs-built_in">print</span>(output)<br></code></pre></div></td></tr></table></figure><p>结果为：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">tensor([[[[ 1.0000, -0.5000],<br>          [-1.0000,  3.0000]]]])<br>tensor([[[[1., 0.],<br>          [0., 3.]]]])<br></code></pre></div></td></tr></table></figure><p>然后我们使用torch.nn中的Sigmoid方法更直观的来查看结果：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> torch.nn <span class="hljs-keyword">import</span> Sigmoid<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><br>test_data = torchvision.datasets.CIFAR10(<span class="hljs-string">&quot;./dataset&quot;</span>, train=<span class="hljs-literal">False</span>, transform=torchvision.transforms.ToTensor(),<br>                                         download=<span class="hljs-literal">True</span>)<br>dataloader = DataLoader(dataset=test_data, batch_size=<span class="hljs-number">64</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyModel</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(MyModel, self).__init__()<br>        self.sigmoid1 = Sigmoid()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, <span class="hljs-built_in">input</span></span>):<br>        output = self.sigmoid1(<span class="hljs-built_in">input</span>)<br>        <span class="hljs-keyword">return</span> output<br><br>myModel = MyModel()<br>writer = SummaryWriter(<span class="hljs-string">&quot;logs_sigmoid&quot;</span>)<br>step = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> dataloader:<br>    imgs, target = data<br>    output = myModel(imgs)<br>    writer.add_images(<span class="hljs-string">&quot;input&quot;</span>, imgs, step)<br>    writer.add_images(<span class="hljs-string">&quot;output&quot;</span>, output, step)<br>    step = step + <span class="hljs-number">1</span><br><br>writer.close()<br></code></pre></div></td></tr></table></figure><p>在tensorboard中查看运行结果：</p><p><img src="/img/pytorch/10.png" /></p><h2 id="线性层-及其他层">8、线性层 及其他层</h2><p>主要还是查看官方文档。</p><h2id="搭建小实例和sequential的使用">9、搭建小实例和Sequential的使用</h2><p>我们使用之前学习过的基础来搭建一个简单的神经网络，例如我们来搭建cifar10的模型，其如下图所示</p><p><img src="/img/pytorch/11.png" /></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyModel</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(MyModel, self).__init__()<br>        self.conv1 = Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">5</span>, padding=<span class="hljs-number">2</span>)<br>        self.maxpool1 = MaxPool2d(<span class="hljs-number">2</span>)<br>        self.conv2 = Conv2d(<span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-number">5</span>, padding=<span class="hljs-number">2</span>)<br>        self.maxpool2 = MaxPool2d(<span class="hljs-number">2</span>)<br>        self.conv3 = Conv2d(<span class="hljs-number">32</span>, <span class="hljs-number">64</span>, <span class="hljs-number">5</span>, padding=<span class="hljs-number">2</span>)<br>        self.maxpool3 = MaxPool2d(<span class="hljs-number">2</span>)<br>        self.flatten = Flatten()<br>        self.linear1 = Linear(<span class="hljs-number">1024</span>, <span class="hljs-number">64</span>)<br>        self.linear2 = Linear(<span class="hljs-number">64</span>, <span class="hljs-number">10</span>)<br><br>        self.model1 = Sequential(<br>            Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">5</span>, padding=<span class="hljs-number">2</span>)<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = self.conv1(x)<br>        x = self.maxpool1(x)<br>        x = self.conv2(x)<br>        x = self.maxpool2(x)<br>        x = self.conv2(x)<br>        x = self.maxpool2(x)<br>        x = self.flatten(x)<br>        x = self.linear1(x)<br>        x = self.linear2(x)<br>        <span class="hljs-keyword">return</span> x<br></code></pre></div></td></tr></table></figure><p>引入了Sequential方法后可以将我们搭建的模型简写出来</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyModel</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.model1 = Sequential(<br>            Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">5</span>, padding=<span class="hljs-number">2</span>),<br>            MaxPool2d(<span class="hljs-number">2</span>),<br>            Conv2d(<span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-number">5</span>, padding=<span class="hljs-number">2</span>),<br>            MaxPool2d(<span class="hljs-number">2</span>),<br>            Conv2d(<span class="hljs-number">32</span>, <span class="hljs-number">64</span>, <span class="hljs-number">5</span>, padding=<span class="hljs-number">2</span>),<br>            MaxPool2d(<span class="hljs-number">2</span>),<br>            Flatten(),<br>            Linear(<span class="hljs-number">1024</span>, <span class="hljs-number">64</span>),<br>            Linear(<span class="hljs-number">64</span>, <span class="hljs-number">10</span>)<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = self.model1(x)<br>        <span class="hljs-keyword">return</span> x<br></code></pre></div></td></tr></table></figure><h2 id="损失函数与反向传播">10、损失函数与反向传播</h2><p>我们可以使用torch.nn中的L1Loss以及MSELoss方法来构造损失函数：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">input</span> = torch.tensor([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], dtype=torch.float32)<br>target = torch.tensor([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>], dtype=torch.float32)<br><br><span class="hljs-built_in">input</span> = torch.reshape(<span class="hljs-built_in">input</span>, (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>))<br>target = torch.reshape(target, (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>))<br><br>loss = L1Loss(reduction=<span class="hljs-string">&#x27;sum&#x27;</span>)<br>result = loss(<span class="hljs-built_in">input</span>, target)<br><br>loss_mse = nn.MSELoss()<br>result_mse = loss_mse(<span class="hljs-built_in">input</span>, target)<br><br><span class="hljs-built_in">print</span>(result)<br><span class="hljs-built_in">print</span>(result_mse)<br></code></pre></div></td></tr></table></figure><p>运行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">tensor(2.)<br>tensor(1.3333)<br></code></pre></div></td></tr></table></figure><p>我们可以利用交叉熵作为损失函数来进行反向传播，利用backward方法：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">myModel = MyModel()<br>loss = nn.CrossEntropyLoss()<br><span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> dataloader:<br>    imgs, targets = data<br>    output = myModel(imgs)<br>    result_loss = loss(output, targets)<br>    result_loss.backward()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ok&quot;</span>)<br></code></pre></div></td></tr></table></figure><h2 id="优化器">11、优化器</h2><p>使用torch.optim中的优化器:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">myModel = MyModel()<br>loss = nn.CrossEntropyLoss()<br>optim = torch.optim.SGD(myModel.parameters(), lr=<span class="hljs-number">0.01</span>)<br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):<br>    runing_loss = <span class="hljs-number">0.0</span><br>    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> dataloader:<br>        imgs, targets = data<br>        output = myModel(imgs)<br>        result_loss = loss(output, targets)<br>        optim.zero_grad()<br>        result_loss.backward()<br>        optim.step()<br>        runing_loss = runing_loss + result_loss<br>    <span class="hljs-built_in">print</span>(runing_loss)<br></code></pre></div></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">tensor(<span class="hljs-number">18666.8984</span>, grad_fn=&lt;AddBackward0&gt;)<br>tensor(<span class="hljs-number">16161.6846</span>, grad_fn=&lt;AddBackward0&gt;)<br>tensor(<span class="hljs-number">15338.8057</span>, grad_fn=&lt;AddBackward0&gt;)<br>...<br></code></pre></div></td></tr></table></figure><h2 id="现有网络模型的使用与修改">12、现有网络模型的使用与修改</h2><p>我们使用torchvision中现有的vgg16模型进行使用：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">vgg16_true = torchvison.models.vgg16(pretrained=<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 添加层</span><br>vgg16_true.classifier.add_module(<span class="hljs-string">&#x27;add_linear&#x27;</span>, nn.Linear(<span class="hljs-number">1000</span>, <span class="hljs-number">10</span>))<br><span class="hljs-comment"># 修改层</span><br>vgg16_true.classifier[<span class="hljs-number">6</span>] = nn.Linear(<span class="hljs-number">4096</span>, <span class="hljs-number">10</span>)<br></code></pre></div></td></tr></table></figure><h2 id="网络模型的保存与读取">13、网络模型的保存与读取</h2><p>保存方法：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">vgg16 = torchvision.models.vgg16(pretrained=<span class="hljs-literal">False</span>)<br><span class="hljs-comment"># 保存方法1</span><br>torch.save(vgg16, <span class="hljs-string">&quot;vgg16_method1.pth&quot;</span>)<br><br><span class="hljs-comment"># 保存方法二，将模型参数保存为字典（官方推荐）</span><br>torch.save(vgg16.state_dict(), <span class="hljs-string">&quot;vgg16_method2.pth&quot;</span>)<br></code></pre></div></td></tr></table></figure><p>读取方法：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 方法1保存的模型进行读取</span><br>model = torch.load(<span class="hljs-string">&quot;vgg16_method1.pth&quot;</span>)<br><br><span class="hljs-comment"># 方法2保存的模型进行读取</span><br>vgg16 = vgg16 = torchvision.models.vgg16(pretrained=<span class="hljs-literal">False</span>)<br>vgg16.load_state_dict(torch.load(<span class="hljs-string">&quot;vgg16_method1.pth&quot;</span>))<br></code></pre></div></td></tr></table></figure><h2 id="完整的模型训练">14、完整的模型训练</h2><p>model.py：用于保存网络模型</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyModel</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(MyModel, self).__init__()<br>        self.model = nn.Sequential(<br>            nn.Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>),<br>            nn.MaxPool2d(<span class="hljs-number">2</span>),<br>            nn.Conv2d(<span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>),<br>            nn.MaxPool2d(<span class="hljs-number">2</span>),<br>            nn.Conv2d(<span class="hljs-number">32</span>, <span class="hljs-number">64</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>),<br>            nn.MaxPool2d(<span class="hljs-number">2</span>),<br>            nn.Flatten(),<br>            nn.Linear(<span class="hljs-number">64</span> * <span class="hljs-number">4</span> * <span class="hljs-number">4</span>, <span class="hljs-number">64</span>),<br>            nn.Linear(<span class="hljs-number">64</span>, <span class="hljs-number">10</span>)<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = self.model(x)<br>        <span class="hljs-keyword">return</span> x<br><br><br><span class="hljs-comment"># 验证</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    myModel = MyModel()<br>    <span class="hljs-built_in">input</span> = torch.ones((<span class="hljs-number">64</span>, <span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>))<br>    output = myModel(<span class="hljs-built_in">input</span>)<br>    <span class="hljs-built_in">print</span>(output.shape)<br></code></pre></div></td></tr></table></figure><p>train.py：进行网络训练</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><br><span class="hljs-keyword">from</span> model <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 准备数据集</span><br>train_data = torchvision.datasets.CIFAR10(<span class="hljs-string">&quot;./dataset&quot;</span>, train=<span class="hljs-literal">True</span>, transform=torchvision.transforms.ToTensor(),<br>                                         download=<span class="hljs-literal">True</span>)<br>test_data = torchvision.datasets.CIFAR10(<span class="hljs-string">&quot;./dataset&quot;</span>, train=<span class="hljs-literal">False</span>, transform=torchvision.transforms.ToTensor(),<br>                                         download=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 获取数据集长度</span><br>train_data_length = <span class="hljs-built_in">len</span>(train_data)<br>test_data_length = <span class="hljs-built_in">len</span>(test_data)<br><br><span class="hljs-comment"># 利用DataLoader加载数据</span><br>train_dataloader = DataLoader(train_data, batch_size=<span class="hljs-number">64</span>)<br>test_dataloader = DataLoader(test_data, batch_size=<span class="hljs-number">64</span>)<br><br><span class="hljs-comment"># 创建网络模型</span><br>myModel = MyModel()<br><br><span class="hljs-comment"># 损失函数</span><br>loss_fn = nn.CrossEntropyLoss()<br><br><span class="hljs-comment"># 优化器</span><br>learning_rate = <span class="hljs-number">0.01</span><br>optimizer = torch.optim.SGD(myModel.parameters(), lr=learning_rate)<br><br><span class="hljs-comment"># 设置训练网络的一些参数</span><br><span class="hljs-comment"># 记录训练的次数</span><br>total_train_step = <span class="hljs-number">0</span><br><span class="hljs-comment"># 记录测试的次数</span><br>total_test_step = <span class="hljs-number">0</span><br><span class="hljs-comment"># 训练论数</span><br>epoch = <span class="hljs-number">10</span><br><br><span class="hljs-comment"># 添加tensorboard</span><br>writer = SummaryWriter(<span class="hljs-string">&quot;logs_train&quot;</span>)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(epoch):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;------第%d轮训练开始------&quot;</span> % (i+<span class="hljs-number">1</span>))<br><br>    <span class="hljs-comment"># 训练步骤开始</span><br>    myModel.train()<br>    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> train_dataloader:<br>        imgs, targets = data<br>        outputs = myModel(imgs)<br>        loss = loss_fn(outputs, targets)<br><br>        <span class="hljs-comment"># 优化器优化模型</span><br>        <span class="hljs-comment"># 利用优化器进行梯度清零</span><br>        optimizer.zero_grad()<br>        <span class="hljs-comment"># 反向传播</span><br>        loss.backward()<br>        optimizer.step()<br><br>        total_train_step = total_train_step + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> total_train_step % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;训练次数：&#123;&#125;，loss：&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(total_train_step, loss.item()))<br>            writer.add_scalar(<span class="hljs-string">&quot;train_loss&quot;</span>, loss.item(), total_train_step)<br><br>    <span class="hljs-comment"># 测试步骤开始</span><br>    myModel.<span class="hljs-built_in">eval</span>()<br>    total_test_loss = <span class="hljs-number">0</span><br>    total_accuracy = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> test_dataloader:<br>            imgs, targets = data<br>            outputs = myModel(imgs)<br>            loss = loss_fn(outputs, targets)<br>            total_test_loss = total_test_loss + loss.item()<br>            accuracy = (outputs.argmax(<span class="hljs-number">1</span>) == targets).<span class="hljs-built_in">sum</span>()<br>            total_accuracy = total_accuracy + accuracy<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;整体测试集上的Loss：&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(total_test_loss))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;整体测试集上的正确率：&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(total_accuracy/test_data_length))<br>    writer.add_scalar(<span class="hljs-string">&quot;test_loss&quot;</span>, total_test_loss, total_test_step)<br>    writer.add_scalar(<span class="hljs-string">&quot;test_accuracy&quot;</span>, total_accuracy/test_data_length, total_test_step)<br>    total_test_step = total_test_step + <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># 保存每轮的数据</span><br>    torch.save(myModel, <span class="hljs-string">&quot;myModel_&#123;&#125;.pth&quot;</span>.<span class="hljs-built_in">format</span>(i))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;模型已保存&quot;</span>)<br><br>writer.close()<br></code></pre></div></td></tr></table></figure><h2 id="使用gpu训练">15、使用GPU训练</h2><h3 id="方法一">方法一</h3><p>我们需要对网络模型、数据、损失函数进行修改</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 构建模型</span><br>myModel = MyModel()<br><span class="hljs-keyword">if</span> torch.cuda.is_available():<br>    myModel = myModel.cuda()<br>    <br><span class="hljs-comment"># 损失函数</span><br>loss_fn = nn.CrossEntropyLoss()<br><span class="hljs-keyword">if</span> torch.cuda.is_available():<br>    loss_fn = loss_fn.cuda()<br>    <br>imgs, targets = data<br><span class="hljs-keyword">if</span> torch.cuda.is_available():<br>imgs = imgs.cuda()<br>targets = targets.cuda()<br></code></pre></div></td></tr></table></figure><h3 id="方法二">方法二</h3><p>需要在文件最开始定义训练的设备</p><p>此时为将设备设置为cpu</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 定义训练的设备</span><br>device = torch.device(<span class="hljs-string">&quot;cpu&quot;</span>)<br><br><span class="hljs-comment"># 构建模型</span><br>myModel = MyModel()<br>myModel.to(device)<span class="hljs-comment"># 模型和损失函数不用重新赋值</span><br><br><span class="hljs-comment"># 损失函数</span><br>loss_fn = nn.CrossEntropyLoss()<br>loss_fn.to(device)<br><br>imgs, targets = data<br>imgs = imgs.to(device)<span class="hljs-comment"># 数据需要重新赋值</span><br>targets = targets.to(device)<br></code></pre></div></td></tr></table></figure><p>如果要使用gpu需要如下设置：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 定义训练的设备</span><br>device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span>)<br></code></pre></div></td></tr></table></figure><p>如果有多个gpu，可以按照如下选择设置：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 定义训练的设备</span><br>device = torch.device(<span class="hljs-string">&quot;cuda：0&quot;</span>)<br></code></pre></div></td></tr></table></figure><h2 id="模型验证套路">16、模型验证套路</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">image_path = <span class="hljs-string">&quot;./img/dog.png&quot;</span><br><br>image = Image.<span class="hljs-built_in">open</span>(image_path)<br>image = image.convert(<span class="hljs-string">&#x27;RGB&#x27;</span>)<br><br>transform = torchvision.transforms.Compose([torchvision.transforms.Resize((<span class="hljs-number">32</span>, <span class="hljs-number">32</span>)),<br>                                            torchvision.transforms.ToTensor()])<br><br>image = transform(image)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyModel</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(MyModel, self).__init__()<br>        self.model = nn.Sequential(<br>            nn.Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>),<br>            nn.MaxPool2d(<span class="hljs-number">2</span>),<br>            nn.Conv2d(<span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>),<br>            nn.MaxPool2d(<span class="hljs-number">2</span>),<br>            nn.Conv2d(<span class="hljs-number">32</span>, <span class="hljs-number">64</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>),<br>            nn.MaxPool2d(<span class="hljs-number">2</span>),<br>            nn.Flatten(),<br>            nn.Linear(<span class="hljs-number">64</span> * <span class="hljs-number">4</span> * <span class="hljs-number">4</span>, <span class="hljs-number">64</span>),<br>            nn.Linear(<span class="hljs-number">64</span>, <span class="hljs-number">10</span>)<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = self.model(x)<br>        <span class="hljs-keyword">return</span> x<br><br><br>myModel = torch.load(<span class="hljs-string">&quot;myModel_0.pth&quot;</span>)<br><span class="hljs-built_in">print</span>(myModel)<br>image = torch.reshape(image, (<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>))<br>myModel.<span class="hljs-built_in">eval</span>()<br><span class="hljs-keyword">with</span> torch.no_grad():<br>    output = myModel(image)<br><span class="hljs-built_in">print</span>(output)<br><span class="hljs-built_in">print</span>(output.argmax(<span class="hljs-number">1</span>))<br></code></pre></div></td></tr></table></figure><p>输出为：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">tensor([[ 0.3308,  0.0307,  0.9064,  0.9474,  0.2715,  0.8123, -0.4077,  0.2044,<br>         -0.4149, -1.0106]])<br>tensor([3])<br></code></pre></div></td></tr></table></figure><p>可以看到最后预测我们的图片属于第三类</p>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线性模型</title>
    <link href="/2022/04/26/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/04/26/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="线性模型">线性模型</h1><h2 id="线性回归">1、线性回归</h2><p>假如咱们有一个数据集，里面的数据是俄勒冈州波特兰市的 <spanclass="math inline">\(47\)</span> 套房屋的面积和价格：</p><table><thead><tr class="header"><th style="text-align: center;">居住面积（平方英尺）</th><th style="text-align: center;">价格（千美元）</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(2104\)</span></td><td style="text-align: center;"><spanclass="math inline">\(400\)</span></td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(1600\)</span></td><td style="text-align: center;"><spanclass="math inline">\(330\)</span></td></tr><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(2400\)</span></td><td style="text-align: center;"><spanclass="math inline">\(369\)</span></td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(1416\)</span></td><td style="text-align: center;"><spanclass="math inline">\(232\)</span></td></tr><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(3000\)</span></td><td style="text-align: center;"><spanclass="math inline">\(540\)</span></td></tr><tr class="even"><td style="text-align: center;">……</td><td style="text-align: center;">……</td></tr></tbody></table><p><img src="/img/线性模型/1.png" /></p><p>如果来了一个新的面积，假设在销售价钱的记录中没有的，我们怎么办呢？</p><p>我们可以用一条曲线去尽量准的拟合这些数据，然后如果有新的输入过来，我们可以将曲线上这个点对应的值返回。这就是线性回归的思想。</p><p>为了让我们的房屋案例更有意思，咱们稍微对数据集进行一下补充，增加上每一个房屋的卧室数目：</p><table><thead><tr class="header"><th style="text-align: center;">居住面积（平方英尺）</th><th style="text-align: center;">卧室数目</th><th style="text-align: center;">价格（千美元）</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(2104\)</span></td><td style="text-align: center;"><spanclass="math inline">\(3\)</span></td><td style="text-align: center;"><spanclass="math inline">\(400\)</span></td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(1600\)</span></td><td style="text-align: center;"><spanclass="math inline">\(3\)</span></td><td style="text-align: center;"><spanclass="math inline">\(330\)</span></td></tr><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(2400\)</span></td><td style="text-align: center;"><spanclass="math inline">\(3\)</span></td><td style="text-align: center;"><spanclass="math inline">\(369\)</span></td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(1416\)</span></td><td style="text-align: center;"><spanclass="math inline">\(2\)</span></td><td style="text-align: center;"><spanclass="math inline">\(232\)</span></td></tr><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(3000\)</span></td><td style="text-align: center;"><spanclass="math inline">\(4\)</span></td><td style="text-align: center;"><spanclass="math inline">\(540\)</span></td></tr><tr class="even"><td style="text-align: center;">……</td><td style="text-align: center;">……</td><td style="text-align: center;">……</td></tr></tbody></table><p>也是同样的方法，此时的自变量就变成了二维向量。</p><p>下面是一个典型的机器学习的过程，首先给出一个输入数据，我们的算法会通过一系列的过程得到一个估计的函数，这个函数有能力对没有见过的新数据给出一个新的估计，也被称为构建一个模型。就如同上面的线性回归函数。</p><p><img src="/img/线性模型/2.png" /></p><p>线性回归假设特征和结果满足线性关系。其实线性关系的表达能力非常强大，每个特征对结果的影响强弱可以有前面的参数体现，而且每个特征变量可以首先映射到一个函数，然后再参与线性计算。这样就可以表达特征与结果之间的非线性关系。</p><p>我们用<span class="math inline">\(x_1\)</span>，<spanclass="math inline">\(x_2\)</span>去描述feature里面的分量，比如 <spanclass="math inline">\(x_1\)</span>=居住面积，<spanclass="math inline">\(x_2\)</span>=卧室数目，我们可以做出一个估计函数：<span class="math display">\[h_\theta  (x) = \theta_0 + \theta_1 \times x_1 + \theta_2 \times x_2\]</span> 简化一下就为： <span class="math display">\[h(x) = \sum^n_{i=0}  \theta_i x_i = \theta^T x\]</span> 我们程序也需要一个机制去评估我们<spanclass="math inline">\(\theta\)</span>是否比较好，所以说需要对我们做出的<spanclass="math inline">\(h\)</span>函数进行评估，一般这个函数称为损失函数（loss function）或者错误函数(errorfunction)，描述<span class="math inline">\(h\)</span>函数不好的程度，在下面，我们称这个函数为<spanclass="math inline">\(J\)</span>函数： <span class="math display">\[J(\theta) = \frac 12 \sum^m_{i=1}(h_\theta(x^{(i)})-y^{(i)})^2\]</span> 如何调整<span class="math inline">\(\theta\)</span>以使得<spanclass="math inline">\(J(\theta)\)</span>取得最小值有很多方法，其中有最小二乘法(leastsquares method)和梯度下降法等。</p><h3 id="最小二乘法">1.1 最小二乘法</h3><p>给定一个训练集，把<strong>设计矩阵（design matrix）</strong> <spanclass="math inline">\(x\)</span> 设置为一个 <spanclass="math inline">\(m\times n\)</span>矩阵（实际上，如果考虑到截距项，也就是 <spanclass="math inline">\(\theta_0\)</span> 那一项，就应该是 <spanclass="math inline">\(m\times (n+1)\)</span>矩阵），这个矩阵里面包含了训练样本的输入值作为每一行：</p><p><span class="math display">\[X =\begin{bmatrix}(x^{(1)}) ^T\\(x^{(2)}) ^T\\\vdots \\(x^{(m)}) ^T\\\end{bmatrix}\]</span></p><p>然后，咱们设 <span class="math inline">\(\vec{y}\)</span> 是一个<span class="math inline">\(m\)</span> 维向量（m-dimensionalvector），其中包含了训练集中的所有目标值：</p><p><span class="math display">\[Y =\begin{bmatrix}y^{(1)}\\y^{(2)}\\\vdots \\y^{(m)}\\\end{bmatrix}\]</span></p><p>假设<span class="math inline">\(h_\theta(x_1,x_2,...,x_m)=\theta_0+\theta_1 \times x_1 + \theta_2 \times x_2 + ... +\theta \timesx_m\)</span>​ 的矩阵表达式为 <span class="math display">\[h_\theta(x)=X_\theta\]</span> 损失函数定义为： <span class="math display">\[\frac \partial {\partial\theta_j}J(\theta) = \frac12 (X_\theta - Y) ^ T(X_\theta - T)\]</span> 这时候我们要对这个损失函数的 <spanclass="math inline">\(\theta\)</span> 向量进行求导取0，结果如下式：<span class="math display">\[\theta = (X^T X)^{-1} X^T Y\]</span></p><h3 id="梯度下降算法">1.2 梯度下降算法</h3><p>我们希望选择一个能让 <span class="math inline">\(J(\theta)\)</span>最小的 <span class="math inline">\(\theta\)</span>值。怎么做呢，咱们先用一个搜索的算法，从某一个对 <spanclass="math inline">\(\theta\)</span> 的“初始猜测值”，然后对 <spanclass="math inline">\(\theta\)</span> 值不断进行调整，来让 <spanclass="math inline">\(J(\theta)\)</span>逐渐变小，最好是直到我们能够达到一个使 <spanclass="math inline">\(J(\theta)\)</span> 最小的 <spanclass="math inline">\(\theta\)</span>。具体来说，咱们可以考虑使用梯度下降法（gradientdescent algorithm），这个方法就是从某一个 <spanclass="math inline">\(\theta\)</span>的初始值开始，然后逐渐重复更新：</p><p><span class="math display">\[\theta_j := \theta_j - \alpha \frac \partial {\partial\theta_j}J(\theta)\]</span></p><p>（上面的这个更新要同时对应从 <span class="math inline">\(0\)</span>到 <span class="math inline">\(n\)</span> 的所有<spanclass="math inline">\(j\)</span> 值进行。）这里的 <spanclass="math inline">\(\alpha\)</span>也称为学习速率。这个算法是很自然的，逐步重复朝向 <spanclass="math inline">\(J\)</span> 降低最快的方向移动。</p><p>要实现这个算法，咱们需要解决等号右边的导数项。首先来解决只有一组训练样本<span class="math inline">\((x, y)\)</span>的情况，这样就可以忽略掉等号右边对 <spanclass="math inline">\(J\)</span> 的求和项目了。公式就简化下面这样：</p><p><span class="math display">\[\begin{aligned}\frac \partial {\partial\theta_j}J(\theta) &amp; = \frac \partial{\partial\theta_j} \frac  12(h_\theta(x)-y)^2\\&amp; = 2 \cdot\frac 12(h_\theta(x)-y)\cdot \frac \partial{\partial\theta_j}  (h_\theta(x)-y) \\&amp; = (h_\theta(x)-y)\cdot \frac \partial{\partial\theta_j}(\sum^n_{i=0} \theta_ix_i-y) \\&amp; = (h_\theta(x)-y) x_j\end{aligned}\]</span></p><p>对单个训练样本，更新规则如下所示：</p><p><span class="math display">\[\theta_j := \theta_j + \alpha (y^{(i)}-h_\theta (x^{(i)}))x_j^{(i)}\]</span></p><p>第一种就是下面这个算法：</p>$<span class="math display">\[\begin{aligned}&amp;\qquad 重复直到收敛 \{ \\&amp;\qquad\qquad\theta_j := \theta_j + \alpha\sum^m_{i=1}(y^{(i)}-h_\theta (x^{(i)}))x_j^{(i)}\quad(对每个j) \\&amp;\qquad\}\end{aligned}\]</span><p>$</p><p>读者很容易能证明，在上面这个更新规则中求和项的值就是<spanclass="math inline">\(\frac {\partial J(\theta)}{\partial\theta_j}\)</span> （这是因为对 <span class="math inline">\(J\)</span>的原始定义）。所以这个更新规则实际上就是对原始的成本函数<spanclass="math inline">\(J\)</span>进行简单的梯度下降。这一方法在每一个步长内检查所有整个训练集中的所有样本，也叫做<strong>批量梯度下降法（batchgradientdescent</strong>）。这里要注意，因为梯度下降法容易被局部最小值影响，而我们要解决的这个线性回归的优化问题只能有一个全局的而不是局部的最优解；因此，梯度下降法应该总是收敛到全局最小值（假设学习速率<span class="math inline">\(\alpha\)</span> 不设置的过大）。</p><p>对咱们之前的房屋数据集进行批量梯度下降来拟合 <spanclass="math inline">\(\theta\)</span>，把房屋价格当作房屋面积的函数来进行预测，我们得到的结果是 <spanclass="math inline">\(\theta_0 = 71.27, \theta_1 =0.1345\)</span>。如果把 <spanclass="math inline">\(h_{\theta}(x)\)</span> 作为一个定义域在 <spanclass="math inline">\(x\)</span>上的函数来投影，同时也投上训练集中的已有数据点，会得到下面这幅图：</p><p><img src="/img/线性模型/3.png" /></p><p>如果在数据集中添加上卧室数目作为输入特征，那么得到的结果就是 <spanclass="math inline">\(\theta_0 = 89.60, \theta_1 = 0.1392, \theta_2 =−8.738\)</span>​。这个结果就是用批量梯度下降法来获得的。</p><p>此外还有另外一种方法能够替代批量梯度下降法，这种方法效果也不错。如下所示：</p>$<span class="math display">\[\begin{aligned}&amp;\qquad循环：\{ \\&amp;\qquad\qquad i从1到m,\{   \\&amp;\qquad\qquad\qquad\theta_j :=\theta_j  +\alpha(y^{(i)}-h_{\theta}(x^{(i)}))x_j^{(i)} \qquad(对每个 j)\\&amp;\qquad\qquad\}  \\&amp;\qquad\}\end{aligned}\]</span><p>$</p><p>在这个算法里，我们对整个训练集进行了循环遍历，每次遇到一个训练样本，根据每个单一训练样本的误差梯度来对参数进行更新。这个算法叫做<strong>随机梯度下降法（stochasticgradient descent）</strong>，或者叫<strong>增量梯度下降法（incrementalgradientdescent）</strong>。批量梯度下降法要在运行第一步之前先对整个训练集进行扫描遍历，当训练集的规模<span class="math inline">\(m\)</span>变得很大的时候，引起的性能开销就很不划算了；随机梯度下降法就没有这个问题，而是可以立即开始，对查询到的每个样本都进行运算。通常情况下，随机梯度下降法查找到足够接近最低值的<span class="math inline">\(\theta\)</span>的速度要比批量梯度下降法更快一些。（也要注意，也有可能会一直无法收敛（converge）到最小值，这时候<span class="math inline">\(\theta\)</span> 会一直在 <spanclass="math inline">\(J(\theta)\)</span>最小值附近震荡；不过通常情况下在最小值附近的这些值大多数其实也足够逼近了，足以满足咱们的精度要求，所以也可以用。）由于这些原因，特别是在训练集很大的情况下，随机梯度下降往往比批量梯度下降更受青睐。</p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
